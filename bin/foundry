#!/usr/bin/env ruby

unless $:.include?(File.dirname(__FILE__) + '/../lib')
  $:.unshift(File.dirname(__FILE__) + '/../lib')
end

require 'bundler'
Bundler.setup

require 'trollop'
require 'foundry'
require 'pp'

opts = Trollop::options do
  version "Foundry Ruby Interpreter/Compiler #{Foundry::VERSION}"
  banner <<-EOS
Usage: foundry [options] filename...

  EOS

  opt :target,   "Target environment",         default: 'dummy'
  opt :evaluate, "Evaluate code",              type: :strings
  opt :dump,     "Dump LLVM IR",               default: false
  opt :output,   "Write bitcode",              type: :string
end

class StandaloneEvaluator < Foundry::Evaluator::Ruby
  def on_repl(node)
    repl = Foundry::REPL::Shell.new(self.outer)
    repl.invoke!

    Foundry::VI::NIL
  end
end

Foundry::Runtime.interpreter = StandaloneEvaluator

begin
  Foundry::Runtime.bootstrap

  Foundry::Runtime.eval <<-REPL, '(prelude)'
  module Kernel
    def repl!
      FoundryRt.repl
    end
  end
  REPL

  if opts[:evaluate]
    opts[:evaluate].each do |value|
      Foundry::Runtime.eval value, '(-e)'
    end
  end

  if ARGV.any? || opts[:evaluate]
    ARGV.each do |input|
      if input == '-'
        Foundry::Runtime.eval STDIN.read, '(stdin)'
      else
        Foundry::Runtime.load input
      end
    end
  else
    Foundry::Runtime.eval 'repl!', '(prelude)'
  end

  translator = Foundry::Runtime.compile

  if opts[:dump]
    translator.llvm_module.dump
  end

  if opts[:output]
    File.open(opts[:output], 'w') do |io|
      translator.llvm_module.write_bitcode(io)
    end
  end
rescue Foundry::Evaluator::Error => e
  puts "Unhandled exception:"
  puts e.inner_exception.inspect
  puts e.inner_backtrace
  puts e.backtrace
  exit!
end