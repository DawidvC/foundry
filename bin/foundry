#!/usr/bin/env ruby

unless $:.include?(File.dirname(__FILE__) + '/../lib')
  $:.unshift(File.dirname(__FILE__) + '/../lib')
end

unless defined?(WARBLER_CONFIG)
  require 'bundler'
  Bundler.setup
end

require 'trollop'
require 'json'
require 'foundry'

opts = Trollop::options do
  version "Foundry Ruby Interpreter/Compiler #{Foundry::VERSION}"
  banner <<-EOS
Usage: foundry [options] filename...

  EOS

  opt :target,     "Target environment",         default: 'dummy'
  opt :evaluate,   "Evaluate code",              type: :strings

  opt :dump_lir,   "Dump LIR",                   default: false,    short: 'I'
  opt :instrument, "Write instrumentation data", type: :string,     short: 'i'

  opt :llvm,       "Write LLVM bitcode",         default: false,    short: 'L'
  opt :assembly,   "Write target assembly",      default: false,    short: 'S'
  opt :output,     "Output filename",            type: :string

  opt :print_maps, "Print /proc/self/maps",      type: :string
end

if opts[:print_maps]
  File.write(opts[:print_maps], File.read('/proc/self/maps'))
  exit
end

Furnace::SSA::PrettyPrinter.colorize = $stdout.tty?

class StandaloneEvaluator < Foundry::Evaluator::Ruby
  def on_repl(node)
    repl = Foundry::REPL::Shell.new(self.outer)
    repl.invoke!

    Foundry::VI::NIL
  end
end

Foundry::Runtime.interpreter = StandaloneEvaluator

begin
  Foundry::Runtime.bootstrap

  Foundry::Runtime.eval <<-REPL, '(prelude)'
  module Kernel
    def repl!
      FoundryRt.repl
    end
  end
  REPL

  if opts[:evaluate]
    opts[:evaluate].each do |value|
      Foundry::Runtime.eval value, '(-e)'
    end
  end

  if ARGV.any? || opts[:evaluate]
    ARGV.each do |input|
      if input == '-'
        Foundry::Runtime.eval STDIN.read, '(stdin)'
      else
        Foundry::Runtime.load input
      end
    end
  else
    Foundry::Runtime.eval 'repl!', '(prelude)'

    exit
  end

  Foundry::Runtime.instrument = !opts[:instrument].nil?
  Foundry::Runtime.graph_lir  = opts[:dump_lir]

  translator = Foundry::LIR::Translator.new

  begin
    Foundry::Runtime.optimize(translator)
  ensure
    if opts[:instrument]
      File.open(opts[:instrument], 'w') do |io|
        io.write JSON.dump(translator.lir_module.instrumentation)
      end

      puts "Instrumentation dumped."
    end

    raise if $!
  end

  Foundry::Runtime.compile(translator)
  machine, linked = Foundry::Runtime.link(translator)

  if opts[:llvm] && opts[:assembly]
    linked.dump
  elsif opts[:output]
    if opts[:llvm]
      File.open(opts[:output], 'w') do |io|
        linked.write_bitcode(io)
      end
    else
      opts[:output] = '/dev/stdout' if opts[:output] == '-'

      machine.emit(linked, opts[:output], opts[:assembly] ? :assembly : :object)
    end
  end

rescue Foundry::Evaluator::Error => e
  puts "Unhandled exception:"
  puts e.inner_exception.inspect
  puts e.inner_backtrace
  puts e.backtrace

rescue Foundry::LIR::AnalysisError => e
  puts "Analysis error:"
  puts "    #{e}"
end
